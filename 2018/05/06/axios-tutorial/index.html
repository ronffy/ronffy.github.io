<!doctype html>
<html lang="en">

<!-- Head -->
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/mylogo.png">

    

    <title>
        
        Axios源码深度剖析 - XHR篇 |
        
        小贼先生
    </title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css">

    <!-- Custom Fonts -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- Plugin CSS -->


    <!-- Custom CSS -->
    <!-- ↓这是stylus文件 -->
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/home.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/toc.css">


</head>


<body>

<!-- Header -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header {
        background-color: #000;
            /*post*/
            
    }

    .navbar-custom .navbar-brand {
        color: #fff;
            /*post*/
            
    }

    .navbar-custom .navbar-subtitle {
        display: none;
            
    }

    @media only screen and (min-width: 768px) {
        .navbar-custom .nav li a {
            color: #fff;
                
        }
    }
</style>


<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- 文章 -->
                
                    <div class="post-heading">
                        <h1>
                            Axios源码深度剖析 - XHR篇
                        </h1>
                        <h2 class="subheading">
                            axios 是一个基于 Promise 的http请求库，本文将从源码深度剖析其实现原理
                        </h2>
                        <p class="subauthor">
                            Posted by 
                            <a href="https://github.com/ronffy">
                                Ronffy
                            </a> on 2018-05-06
                        </p>
                    </div>
                    <!-- 非文章 -->
                    

            </div>
        </div>
    </div>
</header>

<!-- Nav -->
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">小贼先生</a>
            <span class="navbar-subtitle">
                我的code，一块砖一块砖垒成未来的样子
            </span>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    
                    <li><a href="/">首页</a></li>
                    
                    <li><a href="/archives">所有文章</a></li>
                    
                    <li><a href="/about">关于我</a></li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

<!-- Content -->
<!-- Content -->
<div class="container" data-type="post">
    <div class="row">
        <!-- Post container -->
        <div class="
                col-lg-8 col-lg-offset-1
                col-md-8 col-md-offset-1
                col-sm-12
                col-xs-12
                post-container
            " style="padding-top: 15px;">

            <p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a> 是一个基于 Promise 的http请求库，可以用在浏览器和node.js中，目前在github上有 42K 的star数</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol>
<li>每一小节都会从两个方面介绍：如何使用 -&gt; 源码分析</li>
<li>[工具方法简单介绍]一节可先跳过，后面用到了再过来查看</li>
<li>axios最核心的技术点是<a href="#[如何拦截请求响应并修改请求参数修改响应数据]">如何拦截请求响应并修改请求参数修改响应数据</a> 和 <a href="#axios是如何用promise搭起基于xhr的异步桥梁的">axios是如何用promise搭起基于xhr的异步桥梁的</a> </li>
</ol>
<h3 id="axios项目目录结构"><a href="#axios项目目录结构" class="headerlink" title="axios项目目录结构"></a>axios项目目录结构</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">├── /dist/                     <span class="comment"># 项目输出目录</span></span><br><span class="line">├── /<span class="class"><span class="keyword">lib</span>/                      <span class="comment"># 项目源码目录</span></span></span><br><span class="line">│ ├── /cancel/                 <span class="comment"># 定义取消功能</span></span><br><span class="line">│ ├── /core/                   <span class="comment"># 一些核心功能</span></span><br><span class="line">│ │ ├── Axios.js               <span class="comment"># axios的核心主类</span></span><br><span class="line">│ │ ├── dispatchRequest.js     <span class="comment"># 用来调用http请求适配器方法发送请求</span></span><br><span class="line">│ │ ├── InterceptorManager.js  <span class="comment"># 拦截器构造函数</span></span><br><span class="line">│ │ └── settle.js              <span class="comment"># 根据http响应状态，改变Promise的状态</span></span><br><span class="line">│ ├── /helpers/                <span class="comment"># 一些辅助方法</span></span><br><span class="line">│ ├── /adapters/               <span class="comment"># 定义请求的适配器 xhr、http</span></span><br><span class="line">│ │ ├── http.js                <span class="comment"># 实现http适配器</span></span><br><span class="line">│ │ └── xhr.js                 <span class="comment"># 实现xhr适配器</span></span><br><span class="line">│ ├── axios.js                 <span class="comment"># 对外暴露接口</span></span><br><span class="line">│ ├── defaults.js              <span class="comment"># 默认配置 </span></span><br><span class="line">│ └── utils.js                 <span class="comment"># 公用工具</span></span><br><span class="line">├── package.json               <span class="comment"># 项目信息</span></span><br><span class="line">├── index.d.ts                 <span class="comment"># 配置TypeScript的声明文件</span></span><br><span class="line">└── index.js                   <span class="comment"># 入口文件</span></span><br></pre></td></tr></table></figure>
<p>注：因为我们需要要看的代码都是<code>/lib/</code>目录下的文件，所以以下所有涉及到文件路径的地方，<br>我们都会在<code>/lib/</code>下进行查找</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><p>拦截器 interceptors </p>
<p>（如果你熟悉中间件，那么就很好理解了，因为它起到的就是基于promise的中间件的作用）</p>
<p>拦截器分为请求拦截器和响应拦截器，顾名思义：<br>请求拦截器(<code>interceptors.request</code>)是指可以拦截住每次或指定http请求，并可修改配置项<br>响应拦截器(<code>interceptors.response</code>)可以在每次http请求后拦截住每次或指定http请求，并可修改返回结果项。</p>
<p>这里先简单说明，后面会做详细的介绍<a href="#如何拦截请求响应并修改请求参数修改响应数据">如何拦截请求响应并修改请求参数修改响应数据</a>。</p>
</li>
<li><p>数据转换器 （其实就是对数据进行转换，比如将对象转换为JSON字符串）</p>
<p>数据转换器分为请求转换器和响应转换器，顾名思义：<br>请求转换器(<code>transformRequest</code>)是指在请求前对数据进行转换，<br>响应转换器(<code>transformResponse</code>)主要对请求响应后的响应体做数据转换。</p>
</li>
<li><p>http请求适配器（其实就是一个方法）</p>
<p>在axios项目里，http请求适配器主要指两种：XHR、http。<br>XHR的核心是浏览器端的XMLHttpRequest对象，<br>http核心是node的http[s].request方法</p>
<p>当然，axios也留给了用户通过config自行配置适配器的接口的，<br>不过，一般情况下，这两种适配器就能够满足从浏览器端向服务端发请求或者从node的http客户端向服务端发请求的需求。</p>
<p>本次分享主要围绕XHR。</p>
</li>
<li><p>config配置项 （其实就是一个对象）</p>
<p>此处我们说的config，在项目内不是真的都叫config这个变量名，这个名字是我根据它的用途起的一个名字，方便大家理解。</p>
<p>在axios项目中的，设置\读取config时，<br>有的地方叫它<code>defaults</code>(<code>/lib/defaults.js</code>)，这儿是默认配置项，<br>有的地方叫它<code>config</code>，如<code>Axios.prototype.request</code>的参数，再如<code>xhrAdapter</code>http请求适配器方法的参数。</p>
<p>config在axios项目里的是非常重要的一条链，是用户跟axios项目内部“通信”的主要桥梁。</p>
</li>
</ul>
<h3 id="axios内部的运作流程图"><a href="#axios内部的运作流程图" class="headerlink" title="axios内部的运作流程图"></a>axios内部的运作流程图</h3><p><img src="/img/post/axios/axios-tree.jpg" alt=""></p>
<h3 id="工具方法简单介绍"><a href="#工具方法简单介绍" class="headerlink" title="工具方法简单介绍"></a>工具方法简单介绍</h3><p>（注：本节可先跳过，后面用到了再过来查看）</p>
<p>有一些方法在项目中多处使用，简单介绍下这些方法</p>
<ol>
<li>bind： 给某个函数指定上下文，也就是this指向</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bind(fn, context);</span><br></pre></td></tr></table></figure>
<p>实现效果同<code>Function.prototype.bind</code>方法: <code>fn.bind(context)</code></p>
<ol start="2">
<li>forEach：遍历数组或对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="keyword">var</span> forEach = utils.forEach;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">utils.forEach([], (value, index, array) =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">utils.forEach(&#123;&#125;, (value, key, object) =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>merge：深度合并多个对象为一个对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="keyword">var</span> merge = utils.merge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    bb: <span class="number">11</span>,</span><br><span class="line">    bbb: <span class="number">111</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    bb: <span class="number">22</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> mergedObj = merge(obj1, obj2);</span><br></pre></td></tr></table></figure>
<p>mergedObj对象是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  a: <span class="number">2</span>, </span><br><span class="line">  b: &#123; </span><br><span class="line">    bb: <span class="number">22</span>, </span><br><span class="line">    bbb: <span class="number">111</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>extend：将一个对象的方法和属性扩展到另外一个对象上，并指定上下文</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="keyword">var</span> extend = utils.extend;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">  a: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">  k: <span class="string">'k1'</span>,</span><br><span class="line">  fn()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> source = &#123;</span><br><span class="line">  k: <span class="string">'k2'</span>,</span><br><span class="line">  fn()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> extendObj = extend(target, source, context);</span><br></pre></td></tr></table></figure>
<p>extendObj对象是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  k: <span class="string">'k2'</span>,</span><br><span class="line">  fn: source.fn.bind(context),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>extendObj.fn();</code>, 打印<code>3</code></p>
<h3 id="axios为何会有多种使用方式"><a href="#axios为何会有多种使用方式" class="headerlink" title="axios为何会有多种使用方式"></a>axios为何会有多种使用方式</h3><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 首先将axios包引进来</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br></pre></td></tr></table></figure>
<p>第1种使用方式：<code>axios(option)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">  url,</span><br><span class="line">  method,</span><br><span class="line">  headers,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第2种使用方式：<code>axios(url[, option])</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">axios(url, &#123;</span><br><span class="line">  method,</span><br><span class="line">  headers,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第3种使用方式（对于<code>get、delete</code>等方法）：<code>axios[method](url[, option])</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">  headers,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第4种使用方式（对于<code>post、put</code>等方法）：<code>axios[method](url[, data[, option]])</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">axios.post(url, data, &#123;</span><br><span class="line">  headers,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第5种使用方式：<code>axios.request(option)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">axios.request(&#123;</span><br><span class="line">  url,</span><br><span class="line">  method,</span><br><span class="line">  headers,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>作为axios项目的入口文件，我们先来看下<code>axios.js</code>的源码<br>能够实现axios的多种使用方式的核心是<code>createInstance</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/axios.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个Axios实例</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> Axios(defaultConfig);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码也可以这样实现：var instance = Axios.prototype.request.bind(context);</span></span><br><span class="line">  <span class="comment">// 这样instance就指向了request方法，且上下文指向context，所以可以直接以 instance(option) 方式调用 </span></span><br><span class="line">  <span class="comment">// Axios.prototype.request 内对第一个参数的数据类型判断，使我们能够以 instance(url, option) 方式调用</span></span><br><span class="line">  <span class="keyword">var</span> instance = bind(Axios.prototype.request, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把Axios.prototype上的方法扩展到instance对象上，</span></span><br><span class="line">  <span class="comment">// 这样 instance 就有了 get、post、put等方法</span></span><br><span class="line">  <span class="comment">// 并指定上下文为context，这样执行Axios原型链上的方法时，this会指向context</span></span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把context对象上的自身属性和方法扩展到instance上</span></span><br><span class="line">  <span class="comment">// 注：因为extend内部使用的forEach方法对对象做for in 遍历时，只遍历对象本身的属性，而不会遍历原型链上的属性</span></span><br><span class="line">  <span class="comment">// 这样，instance 就有了  defaults、interceptors 属性。（这两个属性后面我们会介绍）</span></span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收默认配置项作为参数（后面会介绍配置项），创建一个Axios实例，最终会被作为对象导出</span></span><br><span class="line"><span class="keyword">var</span> axios = createInstance(defaults);</span><br></pre></td></tr></table></figure>
<p>以上代码看上去很绕，其实<code>createInstance</code>最终是希望拿到一个Function，这个Function指向<code>Axios.prototype.request</code>，这个Function还会有<code>Axios.prototype</code>上的每个方法作为静态方法，且这些方法的上下文都是指向同一个对象。</p>
<p>那么在来看看<code>Axios、Axios.prototype.request</code>的源码是怎样的？</p>
<p><code>Axios</code>是axios包的核心，一个<code>Axios</code>实例就是一个axios应用，其他方法都是对<code>Axios</code>内容的扩展<br>而<code>Axios</code>构造函数的核心方法是<code>request</code>方法，各种axios的调用方式最终都是通过<code>request</code>方法发请求的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/Axios.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.defaults = instanceConfig;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为支持的请求方法提供别名</span></span><br><span class="line">utils.forEach([<span class="string">'delete'</span>, <span class="string">'get'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodNoData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(utils.merge(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">utils.forEach([<span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodWithData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, data, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(utils.merge(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url,</span><br><span class="line">      data: data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过以上代码，我们就可以以多种方式发起http请求了: <code>axios()、axios.get()、axios.post()</code></p>
<p>一般情况，项目使用默认导出的axios实例就可以满足需求了，<br>如果不满足需求需要创建新的axios实例，axios包也预留了接口，<br>看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/axios.js  -  31行</span></span><br><span class="line">axios.Axios = Axios;</span><br><span class="line">axios.create = <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createInstance(utils.merge(defaults, instanceConfig));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>说完axios为什么会有这么多种使用方式，可能你心中会有一个疑问：<br>使用axios时，无论<code>get</code>方法还是<code>post</code>方法，最终都是调用的<code>Axios.prototype.request</code>方法，那么这个方法是怎么根据我们的config配置发请求的呢？</p>
<p>在开始说<code>Axios.prototype.request</code>之前，我们先来捋一捋在axios项目中，用户配置的config是怎么起作用的？</p>
<h3 id="用户配置的config是怎么起作用的"><a href="#用户配置的config是怎么起作用的" class="headerlink" title="用户配置的config是怎么起作用的"></a>用户配置的config是怎么起作用的</h3><p>这里说的<code>config</code>，指的是贯穿整个项目的配置项对象，<br>通过这个对象，可以设置：</p>
<p><code>http请求适配器、请求地址、请求方法、请求头header、
请求数据、请求或响应数据的转换、请求进度、http状态码验证规则、超时、取消请求等</code></p>
<p>可以发现，几乎<code>axios</code>所有的功能都是通过这个对象进行配置和传递的，<br>既是<code>axios</code>项目内部的沟通桥梁，也是用户跟<code>axios</code>进行沟通的桥梁。</p>
<p>首先我们看看，用户能以什么方式定义配置项:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第1种：直接修改Axios实例上defaults属性，主要用来设置通用配置</span></span><br><span class="line">axios.defaults[configName] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2种：发起请求时最终会调用Axios.prototype.request方法，然后传入配置项，主要用来设置“个例”配置</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url,</span><br><span class="line">  method,</span><br><span class="line">  headers,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第3种：新建一个Axios实例，传入配置项，此处设置的是通用配置</span></span><br><span class="line"><span class="keyword">let</span> newAxiosInstance = axios.create(&#123;</span><br><span class="line">  [configName]: value,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>看下 <code>Axios.prototype.request</code> 方法里的一行代码: (<code>/lib/core/Axios.js</code>  -  第35行)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">config = utils.merge(defaults, &#123;<span class="attr">method</span>: <span class="string">'get'</span>&#125;, <span class="keyword">this</span>.defaults, config);</span><br></pre></td></tr></table></figure>
<p>可以发现此处将默认配置对象<code>defaults</code>（<code>/lib/defaults.js</code>）、Axios实例属性<code>this.defaults</code>、<code>request</code>请求的参数<code>config</code>进行了合并。</p>
<p>由此得出，多处配置的优先级由低到高是：<br>—&gt; 默认配置对象<code>defaults</code>（<code>/lib/defaults.js</code>)<br>—&gt;  { method: ‘get’ }<br>—&gt;  Axios实例属性<code>this.defaults</code><br>—&gt;   <code>request</code>请求的参数<code>config</code></p>
<p>留给大家思考一个问题: <code>defaults</code> 和 <code>this.defaults</code> 什么时候配置是相同的，什么时候是不同的？</p>
<p>至此，我们已经得到了将多处<code>merge</code>后的<code>config</code>对象，那么这个对象在项目中又是怎样传递的呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  config = utils.merge(defaults, &#123;<span class="attr">method</span>: <span class="string">'get'</span>&#125;, <span class="keyword">this</span>.defaults, config);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">  <span class="comment">// 将config对象当作参数传给Primise.resolve方法</span></span><br><span class="line">  <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">    <span class="comment">// config会按序通过 请求拦截器 - dispatchRequest方法 - 响应拦截器</span></span><br><span class="line">    <span class="comment">// 关于拦截器 和 dispatchRequest方法，下面会作为一个专门的小节来介绍。</span></span><br><span class="line">    promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>至此，<code>config</code>走完了它传奇的一生 <code>-_-</code><br>下一节就要说到重头戏了: <code>Axios.prototype.request</code></p>
<h3 id="axios-prototype-request"><a href="#axios-prototype-request" class="headerlink" title="axios.prototype.request"></a>axios.prototype.request</h3><p>这里面的代码比较复杂，一些方法需要追根溯源才能搞清楚，<br>所以只需对chain数组有个简单的了解就好，涉及到的<a href="#如何拦截请求响应并修改请求参数修改响应数据">拦截器</a>、[<code>dispatchRequest</code>]后面都会详细介绍</p>
<p><code>chain</code>数组是用来盛放拦截器方法和<code>dispatchRequest</code>方法的，<br>通过promise从<code>chain</code>数组里按序取出回调函数逐一执行，最后将处理后的新的promise在<code>Axios.prototype.request</code>方法里返回出去，<br>并将response或error传送出去，这就是<code>Axios.prototype.request</code>的使命了。</p>
<p>查看源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/Axios.js</span></span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">    promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时，你一定对拦截器充满了好奇，这个拦截器到底是个什么家伙，下一节就让我们一探究竟吧</p>
<h3 id="如何拦截请求响应并修改请求参数修改响应数据"><a href="#如何拦截请求响应并修改请求参数修改响应数据" class="headerlink" title="如何拦截请求响应并修改请求参数修改响应数据"></a>如何拦截请求响应并修改请求参数修改响应数据</h3><h4 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line"><span class="keyword">const</span> myRequestInterceptor = axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在发送http请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config; <span class="comment">// 有且必须有一个config对象被返回</span></span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response; <span class="comment">// 有且必须有一个response对象被返回</span></span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除某次拦截器</span></span><br><span class="line">axios.interceptors.request.eject(myRequestInterceptor);</span><br></pre></td></tr></table></figure>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ol>
<li>是否可以直接 return error？</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> config, error =&gt; &#123;</span><br><span class="line">  <span class="comment">// 是否可以直接 return error ？</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>如何实现promise的链式调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">new</span> People(<span class="string">'whr'</span>).sleep(<span class="number">3000</span>).eat(<span class="string">'apple'</span>).sleep(<span class="number">5000</span>).eat(<span class="string">'durian'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// (等待3s)--&gt; 'whr eat apple' -(等待5s)--&gt; 'whr eat durian'</span></span><br></pre></td></tr></table></figure>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>关于拦截器，<a href="#名词解释">名词解释</a>一节已经做过简单说明。</p>
<p>每个axios实例都有一个<code>interceptors</code>实例属性，<br><code>interceptors</code>对象上有两个属性<code>request</code>、<code>response</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个属性都是一个<code>InterceptorManager</code>实例，而这个<code>InterceptorManager</code>构造函数就是用来管理拦截器的。</p>
<p>我们先来看看<code>InterceptorManager</code>构造函数：</p>
<p><code>InterceptorManager</code>构造函数就是用来实现拦截器的，这个构造函数原型上有3个方法：use、eject、forEach。<br>关于源码，其实是比较简单的，都是用来操作该构造函数的handlers实例属性的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/InterceptorManager.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InterceptorManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handlers = []; <span class="comment">// 存放拦截器方法，数组内每一项都是有两个属性的对象，两个属性分别对应成功和失败后执行的函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往拦截器里添加拦截方法</span></span><br><span class="line">InterceptorManager.prototype.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fulfilled, rejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handlers.push(&#123;</span><br><span class="line">    fulfilled: fulfilled,</span><br><span class="line">    rejected: rejected</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.handlers.length - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来注销指定的拦截器</span></span><br><span class="line">InterceptorManager.prototype.eject = <span class="function"><span class="keyword">function</span> <span class="title">eject</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handlers[id]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handlers[id] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历this.handlers，并将this.handlers里的每一项作为参数传给fn执行</span></span><br><span class="line">InterceptorManager.prototype.forEach = <span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  utils.forEach(<span class="keyword">this</span>.handlers, <span class="function"><span class="keyword">function</span> <span class="title">forEachHandler</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h !== <span class="literal">null</span>) &#123;</span><br><span class="line">      fn(h);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么当我们通过<code>axios.interceptors.request.use</code>添加拦截器后，<br>axios内部又是怎么让这些拦截器能够在请求前、请求后拿到我们想要的数据的呢？</p>
<p>先看下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/Axios.js</span></span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化一个promise对象，状态为resolved，接收到的参数为config对象</span></span><br><span class="line">  <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意：interceptor.fulfilled 或 interceptor.rejected 是可能为undefined</span></span><br><span class="line">  <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">    chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加了拦截器后的chain数组大概会是这样的：</span></span><br><span class="line">  <span class="comment">// [</span></span><br><span class="line">  <span class="comment">//   requestFulfilledFn, requestRejectedFn, ..., </span></span><br><span class="line">  <span class="comment">//   dispatchRequest, undefined,</span></span><br><span class="line">  <span class="comment">//   responseFulfilledFn, responseRejectedFn, ....,</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只要chain数组长度不为0，就一直执行while循环</span></span><br><span class="line">  <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">    <span class="comment">// 数组的 shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</span></span><br><span class="line">    <span class="comment">// 每次执行while循环，从chain数组里按序取出两项，并分别作为promise.then方法的第一个和第二个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照我们使用InterceptorManager.prototype.use添加拦截器的规则，</span></span><br><span class="line">    <span class="comment">// 正好每次添加的就是我们通过InterceptorManager.prototype.use方法添加的成功和失败回调</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过InterceptorManager.prototype.use往拦截器数组里添加拦截器时使用的数组的push方法，</span></span><br><span class="line">    <span class="comment">// 对于请求拦截器:</span></span><br><span class="line">    <span class="comment">// 从拦截器数组按序读到后是通过unshift方法往chain数组数里添加的，又通过shift方法从chain数组里取出的，</span></span><br><span class="line">    <span class="comment">// 所以得出结论：对于请求拦截器，先添加的拦截器会后执行</span></span><br><span class="line">    <span class="comment">// 对于响应拦截器:</span></span><br><span class="line">    <span class="comment">// 从拦截器数组按序读到后是通过push方法往chain数组里添加的，又通过shift方法从chain数组里取出的，</span></span><br><span class="line">    <span class="comment">// 所以得出结论：对于响应拦截器，添加的拦截器先执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个请求拦截器的fulfilled函数会接收到promise对象初始化时传入的config对象，</span></span><br><span class="line">    <span class="comment">// 而请求拦截器又规定用户写的fulfilled函数必须返回一个config对象，</span></span><br><span class="line">    <span class="comment">// 所以通过promise实现链式调用时，每个请求拦截器的fulfilled函数都会接收到一个config对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个响应拦截器的fulfilled函数会接受到dispatchRequest（也就是我们的请求方法）请求到的数据（也就是response对象）,</span></span><br><span class="line">    <span class="comment">// 而响应拦截器又规定用户写的fulfilled函数必须返回一个response对象，</span></span><br><span class="line">    <span class="comment">// 所以通过promise实现链式调用时，每个响应拦截器的fulfilled函数都会接收到一个response对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任何一个拦截器的抛出的错误，都会被下一个拦截器的rejected函数收到，</span></span><br><span class="line">    <span class="comment">// 所以dispatchRequest抛出的错误才会被响应拦截器接收到。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为axios是通过promise实现的链式调用，所以我们可以在拦截器里进行异步操作，</span></span><br><span class="line">    <span class="comment">// 而拦截器的执行顺序还是会按照我们上面说的顺序执行，</span></span><br><span class="line">    <span class="comment">// 也就是 dispatchRequest 方法一定会等待所有的请求拦截器执行完后再开始执行，</span></span><br><span class="line">    <span class="comment">// 响应拦截器一定会等待 dispatchRequest 执行完后再开始执行。</span></span><br><span class="line"></span><br><span class="line">    promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，你应该已经清楚了拦截器是怎么回事，以及拦截器是如何在<code>Axios.prototype.request</code>方法里发挥作用的了，<br>那么处于”中游位置”的<code>dispatchRequest</code>是如何发送http请求的呢？</p>
<h3 id="dispatchrequest都做了哪些事"><a href="#dispatchrequest都做了哪些事" class="headerlink" title="dispatchrequest都做了哪些事"></a>dispatchrequest都做了哪些事</h3><p>dispatchRequest主要做了3件事：<br>1，拿到config对象，对config进行传给http请求适配器前的最后处理；<br>2，http请求适配器根据config配置，发起请求<br>3，http请求适配器请求完成后，如果成功则根据header、data、和config.transformResponse（关于transformResponse，下面的<a href="#数据转换器-转换请求与响应数据">数据转换器</a>会进行讲解）拿到数据转换后的response，并return。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/dispatchRequest.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  throwIfCancellationRequested(config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Support baseURL config</span></span><br><span class="line">  <span class="keyword">if</span> (config.baseURL &amp;&amp; !isAbsoluteURL(config.url)) &#123;</span><br><span class="line">    config.url = combineURLs(config.baseURL, config.url);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure headers exist</span></span><br><span class="line">  config.headers = config.headers || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对请求data进行转换</span></span><br><span class="line">  config.data = transformData(</span><br><span class="line">    config.data,</span><br><span class="line">    config.headers,</span><br><span class="line">    config.transformRequest</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对header进行合并处理</span></span><br><span class="line">  config.headers = utils.merge(</span><br><span class="line">    config.headers.common || &#123;&#125;,</span><br><span class="line">    config.headers[config.method] || &#123;&#125;,</span><br><span class="line">    config.headers || &#123;&#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除header属性里无用的属性</span></span><br><span class="line">  utils.forEach(</span><br><span class="line">    [<span class="string">'delete'</span>, <span class="string">'get'</span>, <span class="string">'head'</span>, <span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>, <span class="string">'common'</span>],</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cleanHeaderConfig</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">delete</span> config.headers[method];</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// http请求适配器会优先使用config上自定义的适配器，没有配置时才会使用默认的XHR或http适配器，</span></span><br><span class="line">  <span class="comment">// 不过大部分时候，axios提供的默认适配器是能够满足我们的</span></span><br><span class="line">  <span class="keyword">var</span> adapter = config.adapter || defaults.adapter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adapter(config).then(<span class="comment">/**/</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>好了，看到这里，我们是时候梳理一下：axios是如何用promise搭起基于xhr的异步桥梁的？</p>
<h3 id="axios是如何用promise搭起基于xhr的异步桥梁的"><a href="#axios是如何用promise搭起基于xhr的异步桥梁的" class="headerlink" title="axios是如何用promise搭起基于xhr的异步桥梁的"></a>axios是如何用promise搭起基于xhr的异步桥梁的</h3><p>axios是如何通过Promise进行异步处理的？</p>
<h4 id="如何使用-2"><a href="#如何使用-2" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">axios.get(<span class="comment">/**/</span>)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 此处可以拿到向服务端请求回的数据</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 此处可以拿到请求失败或取消或其他处理失败的错误对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><p>先来一个图简单的了解下axios项目里，http请求完成后到达用户的顺序流：</p>
<p><img src="/img/post/axios/promise-tree.png" alt=""></p>
<p>通过<a href="#axios为何会有多种使用方式">axios为何会有多种使用方式</a>我们知道，<br>用户无论以什么方式调用axios，最终都是调用的<code>Axios.prototype.request</code>方法，<br>这个方法最终返回的是一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">  <span class="comment">// 将config对象当作参数传给Primise.resolve方法</span></span><br><span class="line">  <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">    promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Axios.prototype.request</code>方法会调用<code>dispatchRequest</code>方法，而<code>dispatchRequest</code>方法会调用<code>xhrAdapter</code>方法，<code>xhrAdapter</code>方法返回的是还一个Promise对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/adapters/xhr.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchXhrRequest</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>xhrAdapter</code>内的XHR发送请求成功后会执行这个Promise对象的<code>resolve</code>方法,并将请求的数据传出去,<br>反之则执行<code>reject</code>方法，并将错误信息作为参数传出去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/adapters/xhr.js</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> loadEvent = <span class="string">'onreadystatechange'</span>;</span><br><span class="line"></span><br><span class="line">request[loadEvent] = <span class="function"><span class="keyword">function</span> <span class="title">handleLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 往下走有settle的源码</span></span><br><span class="line">  settle(resolve, reject, response);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> <span class="title">handleError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  reject(<span class="comment">/**/</span>);</span><br><span class="line">  request = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">request.ontimeout = <span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  reject(<span class="comment">/**/</span>);</span><br><span class="line">  request = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>验证服务端的返回结果是否通过验证：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/settle.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">settle</span>(<span class="params">resolve, reject, response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> validateStatus = response.config.validateStatus;</span><br><span class="line">  <span class="keyword">if</span> (!response.status || !validateStatus || validateStatus(response.status)) &#123;</span><br><span class="line">    resolve(response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(<span class="comment">/**/</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回到<code>dispatchRequest</code>方法内，首先得到<code>xhrAdapter</code>方法返回的Promise对象,<br>然后通过<code>.then</code>方法，对<code>xhrAdapter</code>返回的Promise对象的成功或失败结果再次加工，<br>成功的话，则将处理后的<code>response</code>返回，<br>失败的话，则返回一个状态为<code>rejected</code>的Promise对象，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span> <span class="title">onAdapterResolution</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">onAdapterRejection</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么至此，用户调用<code>axios()</code>方法时，就可以直接调用Promise的<code>.then</code>或<code>.catch</code>进行业务处理了。</p>
<p>回过头来，我们在介绍<code>dispatchRequest</code>一节时说到的数据转换，而axios官方也将数据转换专门作为一个亮点来介绍的，那么数据转换到底能在使用axios发挥什么功效呢？</p>
<h3 id="数据转换器-转换请求与响应数据"><a href="#数据转换器-转换请求与响应数据" class="headerlink" title="数据转换器-转换请求与响应数据"></a>数据转换器-转换请求与响应数据</h3><h4 id="如何使用-3"><a href="#如何使用-3" class="headerlink" title="如何使用"></a>如何使用</h4><ol>
<li>修改全局的转换器</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 往现有的请求转换器里增加转换方法</span></span><br><span class="line">axios.defaults.transformRequest.push(<span class="function">(<span class="params">data, headers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...处理data</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写请求转换器</span></span><br><span class="line">axios.defaults.transformRequest = [<span class="function">(<span class="params">data, headers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...处理data</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往现有的响应转换器里增加转换方法</span></span><br><span class="line">axios.defaults.transformResponse.push(<span class="function">(<span class="params">data, headers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...处理data</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写响应转换器</span></span><br><span class="line">axios.defaults.transformResponse = [<span class="function">(<span class="params">data, headers</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...处理data</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改某次axios请求的转换器</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 往已经存在的转换器里增加转换方法</span></span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  transformRequest: [</span><br><span class="line">    ...axios.defaults.transformRequest, <span class="comment">// 去掉这行代码就等于重写请求转换器了</span></span><br><span class="line">    (data, headers) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ...处理data</span></span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  transformResponse: [</span><br><span class="line">    ...axios.defaults.transformResponse, <span class="comment">// 去掉这行代码就等于重写响应转换器了</span></span><br><span class="line">    (data, headers) =&gt; &#123;</span><br><span class="line">      <span class="comment">// ...处理data</span></span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码分析-3"><a href="#源码分析-3" class="headerlink" title="源码分析"></a>源码分析</h4><p>默认的<code>defaults</code>配置项里已经自定义了一个请求转换器和一个响应转换器，<br>看下源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/defaults.js</span></span><br><span class="line"><span class="keyword">var</span> defaults = &#123;</span><br><span class="line"></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> <span class="title">transformRequest</span>(<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">    normalizeHeaderName(headers, <span class="string">'Content-Type'</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (utils.isArrayBufferView(data)) &#123;</span><br><span class="line">      <span class="keyword">return</span> data.buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (utils.isURLSearchParams(data)) &#123;</span><br><span class="line">      setContentTypeIfUnset(headers, <span class="string">'application/x-www-form-urlencoded;charset=utf-8'</span>);</span><br><span class="line">      <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (utils.isObject(data)) &#123;</span><br><span class="line">      setContentTypeIfUnset(headers, <span class="string">'application/json;charset=utf-8'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> <span class="title">transformResponse</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">/* Ignore */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么在axios项目里，是在什么地方使用了转换器呢？</p>
<p>请求转换器的使用地方是http请求前，使用请求转换器对请求数据做处理，<br>然后传给http请求适配器使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/dispatchRequest.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  config.data = transformData(</span><br><span class="line">    config.data,</span><br><span class="line">    config.headers,</span><br><span class="line">    config.transformRequest</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> adapter(config).then(<span class="comment">/* ... */</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看下<code>transformData</code>方法的代码，<br>主要遍历转换器数组，分别执行每一个转换器，根据data和headers参数，返回新的data。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/transformData.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformData</span>(<span class="params">data, headers, fns</span>) </span>&#123;</span><br><span class="line">  utils.forEach(fns, <span class="function"><span class="keyword">function</span> <span class="title">transform</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    data = fn(data, headers);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>响应转换器的使用地方是在http请求完成后，根据http请求适配器的返回值做数据转换处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/dispatchRequest.js</span></span><br><span class="line"><span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span> <span class="title">onAdapterResolution</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    response.data = transformData(</span><br><span class="line">      response.data,</span><br><span class="line">      response.headers,</span><br><span class="line">      config.transformResponse</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">onAdapterRejection</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isCancel(reason)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (reason &amp;&amp; reason.response) &#123;</span><br><span class="line">        reason.response.data = transformData(</span><br><span class="line">          reason.response.data,</span><br><span class="line">          reason.response.headers,</span><br><span class="line">          config.transformResponse</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="转换器和拦截器的关系？"><a href="#转换器和拦截器的关系？" class="headerlink" title="转换器和拦截器的关系？"></a>转换器和拦截器的关系？</h4><p>拦截器同样可以实现转换请求和响应数据的需求，但根据作者的设计和综合代码可以看出，<br>在请求时，拦截器主要负责修改config配置项，数据转换器主要负责转换请求体，比如转换对象为字符串<br>在请求响应后，拦截器可以拿到<code>response</code>，数据转换器主要负责处理响应体，比如转换字符串为对象。</p>
<p>axios官方是将”自动转换为JSON数据”作为一个独立的亮点来介绍的，那么数据转换器是如何完成这个功能的呢？<br>其实非常简单，我们一起看下吧。</p>
<h3 id="自动转换json数据"><a href="#自动转换json数据" class="headerlink" title="自动转换json数据"></a>自动转换json数据</h3><p>在默认情况下，axios将会自动的将传入的data对象序列化为JSON字符串，将响应数据中的JSON字符串转换为JavaScript对象</p>
<h4 id="源码分析-4"><a href="#源码分析-4" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 请求时，将data数据转换为JSON 字符串</span></span><br><span class="line"><span class="comment">// /lib/defaults.js </span></span><br><span class="line">transformRequest: [<span class="function"><span class="keyword">function</span> <span class="title">transformRequest</span>(<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (utils.isObject(data)) &#123;</span><br><span class="line">      setContentTypeIfUnset(headers, <span class="string">'application/json;charset=utf-8'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到响应后，将请求到的数据转换为JSON对象</span></span><br><span class="line"><span class="comment">// /lib/defaults.js</span></span><br><span class="line">transformResponse: [<span class="function"><span class="keyword">function</span> <span class="title">transformResponse</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        data = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">/* Ignore */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>至此，axios项目的运作流程已经介绍完毕，是不是已经打通了任督二脉了呢<br>接下来我们一起看下axios还带给了我们哪些好用的技能点吧。</p>
<h3 id="header设置"><a href="#header设置" class="headerlink" title="header设置"></a>header设置</h3><h4 id="如何使用-4"><a href="#如何使用-4" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置通用header</span></span><br><span class="line">axios.defaults.headers.common[<span class="string">'X-Requested-With'</span>] = <span class="string">'XMLHttpRequest'</span>; <span class="comment">// xhr标识</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置某种请求的header</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded;charset=utf-8'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置某次请求的header</span></span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'whr1'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="源码分析-5"><a href="#源码分析-5" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/dispatchRequest.js  -  44行</span></span><br><span class="line"></span><br><span class="line">  config.headers = utils.merge(</span><br><span class="line">    config.headers.common || &#123;&#125;,</span><br><span class="line">    config.headers[config.method] || &#123;&#125;,</span><br><span class="line">    config.headers || &#123;&#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<h3 id="如何取消已经发送的请求"><a href="#如何取消已经发送的请求" class="headerlink" title="如何取消已经发送的请求"></a>如何取消已经发送的请求</h3><h4 id="如何使用-5"><a href="#如何使用-5" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种取消方法</span></span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="params">cancel</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 取消条件 */</span>) &#123;</span><br><span class="line">      cancel(<span class="string">'取消日志'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种取消方法</span></span><br><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line">axios.get(url, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;);</span><br><span class="line">source.cancel(<span class="string">'取消日志'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="源码分析-6"><a href="#源码分析-6" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /cancel/CancelToken.js  -  11行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> resolvePromise;</span><br><span class="line">  <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">promiseExecutor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolvePromise = resolve;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> token = <span class="keyword">this</span>;</span><br><span class="line">  executor(<span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token.reason) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    token.reason = <span class="keyword">new</span> Cancel(message);</span><br><span class="line">    resolvePromise(token.reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /lib/adapters/xhr.js  -  159行</span></span><br><span class="line"><span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">    config.cancelToken.promise.then(<span class="function"><span class="keyword">function</span> <span class="title">onCanceled</span>(<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        request.abort();</span><br><span class="line">        reject(cancel);</span><br><span class="line">        request = <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消功能的核心是通过CancelToken内的<code>this.promise = new Promise(resolve =&gt; resolvePromise = resolve)</code>，<br>得到实例属性<code>promise</code>，此时该<code>promise</code>的状态为<code>pending</code><br>通过这个属性，在<code>/lib/adapters/xhr.js</code>文件中继续给这个<code>promise</code>实例添加<code>.then</code>方法<br>（<code>xhr.js</code>文件的159行<code>config.cancelToken.promise.then(message =&gt; request.abort())</code>）；</p>
<p>在<code>CancelToken</code>外界，通过<code>executor</code>参数拿到对<code>cancel</code>方法的控制权，<br>这样当执行<code>cancel</code>方法时就可以改变实例的<code>promise</code>属性的状态为<code>rejected</code>，<br>从而执行<code>request.abort()</code>方法达到取消请求的目的。</p>
<p>上面第二种写法可以看作是对第一种写法的完善，<br>因为很多是时候我们取消请求的方法是用在本次请求方法外，<br>例如，发送A、B两个请求，当B请求成功后，取消A请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 第1种写法：</span></span><br><span class="line"><span class="keyword">let</span> source;</span><br><span class="line">axios.get(Aurl, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> axios.CancelToken(<span class="function"><span class="params">cancel</span> =&gt;</span> &#123;</span><br><span class="line">    source = cancel;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">axios.get(Burl)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> source(<span class="string">'B请求成功了'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2种写法：</span></span><br><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line">axios.get(Aurl, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;);</span><br><span class="line">axios.get(Burl)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> source.cancel(<span class="string">'B请求成功了'</span>));</span><br></pre></td></tr></table></figure>
<p>相对来说，我更推崇第1种写法，因为第2种写法太隐蔽了，不如第一种直观好理解。</p>
<h5 id="发现的问题"><a href="#发现的问题" class="headerlink" title="发现的问题"></a>发现的问题</h5><ol>
<li><p>/lib/adapters/xhr.js文件中，onCanceled方法的参数不应该叫message么，为什么叫cancel？</p>
</li>
<li><p>/lib/adapters/xhr.js文件中，onCanceled方法里，reject里应该将config信息也传出来</p>
</li>
</ol>
<h3 id="跨域携带cookie"><a href="#跨域携带cookie" class="headerlink" title="跨域携带cookie"></a>跨域携带cookie</h3><h4 id="如何使用-6"><a href="#如何使用-6" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h4 id="源码分析-7"><a href="#源码分析-7" class="headerlink" title="源码分析"></a>源码分析</h4><p>我们在<a href="#用户配置的config是怎么起作用的">用户配置的config是怎么起作用的</a>一节已经介绍了config在axios项目里的传递过程，<br>由此得出，我们通过<code>axios.defaults.withCredentials = true</code>做的配置，<br>在<code>/lib/adapters/xhr.js</code>里是可以取到的，然后通过以下代码配置到xhr对象项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// /lib/adapters/xhr.js</span></span><br><span class="line"><span class="keyword">if</span> (config.withCredentials) &#123;</span><br><span class="line">  request.withCredentials = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="超时配置及处理"><a href="#超时配置及处理" class="headerlink" title="超时配置及处理"></a>超时配置及处理</h3><h4 id="如何使用-7"><a href="#如何使用-7" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">axios.defaults.timeout = <span class="number">3000</span>;</span><br></pre></td></tr></table></figure>
<h4 id="源码分析-8"><a href="#源码分析-8" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /adapters/xhr.js</span></span><br><span class="line">request.timeout = config.timeout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /adapters/xhr.js</span></span><br><span class="line"><span class="comment">// 通过createError方法，将错误信息合为一个字符串</span></span><br><span class="line">request.ontimeout = <span class="function"><span class="keyword">function</span> <span class="title">handleTimeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  reject(createError(<span class="string">'timeout of '</span> + config.timeout + <span class="string">'ms exceeded'</span>, </span><br><span class="line">    config, <span class="string">'ECONNABORTED'</span>, request));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>axios库外如何添加超时后的处理</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">axios().catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; message &#125; = error;</span><br><span class="line">  <span class="keyword">if</span> (message.indexOf(<span class="string">'timeout'</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="改写验证成功或失败的规则validatestatus"><a href="#改写验证成功或失败的规则validatestatus" class="headerlink" title="改写验证成功或失败的规则validatestatus"></a>改写验证成功或失败的规则validatestatus</h3><p>自定义http状态码的成功、失败范围</p>
<h4 id="如何使用-8"><a href="#如何使用-8" class="headerlink" title="如何使用"></a>如何使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">axios.defaults.validateStatus = <span class="function"><span class="params">status</span> =&gt;</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<h4 id="源码分析-9"><a href="#源码分析-9" class="headerlink" title="源码分析"></a>源码分析</h4><p>在默认配置中，定义了默认的http状态码验证规则，<br>所以自定义<code>validateStatus</code>其实是对此处方法的重写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// `/lib/defaults.js`</span></span><br><span class="line"><span class="keyword">var</span> defaults = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> <span class="title">validateStatus</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>axios是何时开始验证http状态码的？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/adapters/xhr.js</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> loadEvent = <span class="string">'onreadystatechange'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /lib/adapters/xhr.js</span></span><br><span class="line"><span class="comment">// 每当 readyState 改变时，就会触发 onreadystatechange 事件</span></span><br><span class="line">request[loadEvent] = <span class="function"><span class="keyword">function</span> <span class="title">handleLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!request || (request.readyState !== <span class="number">4</span> &amp;&amp; !xDomain)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">  <span class="keyword">var</span> response = &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)</span></span><br><span class="line">      status: request.status === <span class="number">1223</span> ? <span class="number">204</span> : request.status,</span><br><span class="line">      config: config,</span><br><span class="line">  &#125;;</span><br><span class="line">  settle(resolve, reject, response);</span><br><span class="line">  <span class="comment">// ...省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// /lib/core/settle.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">settle</span>(<span class="params">resolve, reject, response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果我们往上捣一捣就会发现，config对象的validateStatus就是我们自定义的validateStatus方法或默认的validateStatus方法</span></span><br><span class="line">  <span class="keyword">var</span> validateStatus = response.config.validateStatus;</span><br><span class="line">  <span class="comment">// validateStatus验证通过，就会触发resolve方法</span></span><br><span class="line">  <span class="keyword">if</span> (!response.status || !validateStatus || validateStatus(response.status)) &#123;</span><br><span class="line">    resolve(response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(createError(</span><br><span class="line">      <span class="string">'Request failed with status code '</span> + response.status,</span><br><span class="line">      response.config,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      response.request,</span><br><span class="line">      response</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>axios这个项目里，有很多对JS使用很巧妙的地方，比如对promise的串联操作（当然你也可以说这块是借鉴很多异步中间件的处理方式）,让我们可以很方便对请求前后的各种处理方法的流程进行控制；很多实用的小优化，比如请求前后的数据处理，省了程序员一遍一遍去写JSON.xxx了；同时支持了浏览器和node两种环境，对使用node的项目来说无疑是极好的。</p>
<p>总之，这个能够在github斩获42K+（截止2018.05.27）的star，实力绝不是概的，值得好好交交心！</p>

            
            <!-- Pager -->
            <ul class="pager">
                
                <li class="previous">
                    <a href="/2018/06/26/mixin-class/" >&larr; Mixin配合class实现多继承的绝佳妙用</a>
                </li>
                
                
                <li class="next">
                    <a href="/2017/12/09/去TM的世界/" >《去TM的世界》 &rarr;</a>
                </li>
                
            </ul>



        </div>
        <!-- Sidebar container-->
        <div class="
    col-lg-3 col-lg-offset-0
    col-md-3 col-md-offset-0
    col-sm-12
    col-xs-12
    sidebar-container
">
            <!-- toc -->
            <div class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix-top" role="complementary">
                <h4>目录</h4>
                <ul class="nav bs-docs-sidenav">

                </ul>

            </div>

        </div>
    </div>
</div>

<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a target="_blank"  href="https://github.com/ronffy">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 小贼先生 2019
                    <br>
                    Theme by <a href="https://ronffy.github.io">Ronffy</a>
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="https://cdn.staticfile.org/jquery/2.2.4/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/script.js"></script>




</body>
</html>